if has('vim_starting')
	" Required:
	set runtimepath+=~/dotfiles/.vim/bundle/neobundle.vim/
endif

call neobundle#begin(expand('~/dotfiles/.vim/bundle/'))
NeoBundleFetch 'Shougo/neobundle.vim'

 " My Bundles here:
 " Refer to |:NeoBundle-examples|.
 " Note: You don't set neobundle setting in .gvimrc!
NeoBundle 'scrooloose/nerdtree' " Display editing files
NeoBundle 'thinca/vim-quickrun' " Run command
NeoBundle 'scrooloose/syntastic' " Syntax checker
NeoBundle 'tpope/vim-fugitive' " Git
NeoBundle 'kannokanno/previm' " Preview Markdown
NeoBundle "nathanaelkane/vim-indent-guides" " Show indent
NeoBundle 'mattn/emmet-vim' " HTML Support
NeoBundle 'digitaltoad/vim-jade' " Jade syntax
NeoBundle 'pangloss/vim-javascript' " Javascript syntax
NeoBundle 'itchyny/lightline.vim' " Cool status line
NeoBundle 'kchmck/vim-coffee-script' " Coffeescript syntax
NeoBundle 'majutsushi/tagbar' " Show tags using ctag

" QuickRun
"""""""""""""""""""""""""""""""""
let g:quickrun_config = {}

" Coffeescript
"""""""""""""""""""""""""""""""""
" set filetype
au BufRead,BufNewFile,BufReadPre *.coffee   set filetype=coffee
" show error
autocmd QuickFixCmdPost * nested cwindow | redraw! 

" Display indent
"""""""""""""""""""""""""""""""""
set ts=4 sw=4 noet
let g:indent_guides_enable_on_vim_startup=1
let g:indent_guides_start_level=1
let g:indent_guides_auto_colors=0
let g:indent_guides_guide_size=1
autocmd VimEnter,ColorScheme * :hi IndentGuidesOdd	guibg=#444433	ctermbg=234
autocmd VimEnter,ColorScheme * :hi IndentGuidesEven	guibg=#333344	ctermbg=235

" Nerd tree
"""""""""""""""""""""""""""""""""
let g:NERDTreeQuitOnOpen=1

" Tagbar
"""""""""""""""""""""""""""""""""
let g:tagbar_autoshowtag=1
let g:tagbar_autofocus=1
let g:tagbar_autoclose = 1

" Auto complete
"""""""""""""""""""""""""""""""""
if has('lua') && v:version >= 703 && has('patch885')
	NeoBundleLazy "Shougo/neocomplete.vim", {
		\ "autoload": {
		\   "insert": 1,
		\ }}
	let g:neocomplete#enable_at_startup = 1
	let s:hooks = neobundle#get_hooks("neocomplete.vim")
	function! s:hooks.on_source(bundle)
		let g:acp_enableAtStartup = 0
		let g:neocomplete#enable_smart_case = 1

		" Recommended key-mappings.
		" <CR>: close popup and save indent.
		inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
		function! s:my_cr_function()
			" return neocomplete#smart_close_popup() . "\<CR>"
			" For no inserting <CR> key.
			return pumvisible() ? neocomplete#close_popup() : "\<CR>"
		endfunction
		" <TAB>: completion.
		inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
		" <C-h>, <BS>: close popup and delete backword char.
		inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
		inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
		inoremap <expr><C-y>  neocomplete#close_popup()
		inoremap <expr><C-e>  neocomplete#cancel_popup()
		" Close popup by <Space>.
		" inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"
		" Disable auto select
		let g:neocomplete#enable_auto_select = 0
	endfunction

else
	NeoBundleLazy "Shougo/neocomplcache.vim", {
		\ "autoload": {
		\   "insert": 1,
		\ }}
	let g:neocomplcache_enable_at_startup = 1
	let s:hooks = neobundle#get_hooks("neocomplcache.vim")
	function! s:hooks.on_source(bundle)
		let g:acp_enableAtStartup = 0
		let g:neocomplcache_enable_smart_case = 1

		" Recommended key-mappings.
		" <CR>: close popup and save indent.
		inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
		function! s:my_cr_function()
			" return neocomplcache#smart_close_popup() . "\<CR>"
			" For no inserting <CR> key.
			return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
		endfunction
		" <TAB>: completion.
		inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
		" <C-h>, <BS>: close popup and delete backword char.
		inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
		inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
		inoremap <expr><C-y>  neocomplcache#close_popup()
		inoremap <expr><C-e>  neocomplcache#cancel_popup()
		" Close popup by <Space>.
		" inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
		" Disable auto select
		let g:neocomplcache_enable_auto_select = 0
	endfunction
endif

" lightline
"""""""""""""""""""""""""""""""""
let g:lightline = {
      \ 'mode_map': { 'c': 'NORMAL' },
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ]
      \ },
      \ 'component_function': {
      \   'modified': 'MyModified',
      \   'readonly': 'MyReadonly',
      \   'fugitive': 'MyFugitive',
      \   'filename': 'MyFilename',
      \   'fileformat': 'MyFileformat',
      \   'filetype': 'MyFiletype',
      \   'fileencoding': 'MyFileencoding',
      \   'mode': 'MyMode',
      \ },
      \ 'separator': { 'left': '>', 'right': '<' },
      \ 'subseparator': { 'left': '|', 'right': '|' }
      \ }

function! MyModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '⭤' : ''
endfunction

function! MyFilename()
  return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() : 
        \  &ft == 'unite' ? unite#get_status_string() : 
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  if &ft !~? 'vimfiler\|gundo' && exists("*fugitive#head")
    let _ = fugitive#head()
    return strlen(_) ? '⭠ '._ : ''
  endif
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction

set laststatus=2

" Syntastic
"""""""""""""""""""""""""""""""""
set statusline+=%#warningmsg#
set statusline+=%{exists('g:loaded_syntastic_plugin')?SyntasticStatuslineFlag():''}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

"""""""""""""""""""""""""""""""""
" Final settings
"""""""""""""""""""""""""""""""""
call neobundle#end()
filetype plugin indent on
NeoBundleCheck

